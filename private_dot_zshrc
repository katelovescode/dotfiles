export ZSH="/Users/katedonaldson/.oh-my-zsh"

# sets the editor for chezmoi to Visual Studio Code
export EDITOR="code"

PATH="$(ruby -r rubygems -e 'puts Gem.user_dir')/bin:$PATH"

ZSH_THEME="spaceship"

plugins=(aphorism docker docker-compose git git-extras gitfast node npm rails vscode)

source $ZSH/oh-my-zsh.sh

export HISTSIZE=1000000000
export SAVEHIST=$HISTSIZE
setopt EXTENDED_HISTORY

# https://github.com/microsoft/vscode-remote-release/issues/930#issuecomment-511489074
cd .

alias bi='bundle install'
alias be='bundle exec'

# Zsh
alias rezsh='source ~/.zshrc'

# Docker
alias dbuild='docker-compose up -d --build'
alias dup='docker-compose up -d'
alias ddown='docker-compose down'
alias drm='docker rm $(docker ps -a -q)'
alias dkill='docker system prune --all'

# Git
alias gcm='git cln master'
alias gcd='git cln develop'

function pie() {
  if [ -d "$HOME/Projects/pieforproviders" ]; then
    cd ~/Projects/pieforproviders
  elif [ -d "$HOME/Projects/Personal/pieforproviders" ]; then
    cd ~/Projects/Personal/pieforproviders
  else
    echo "There is no directory for pie"
  fi
}

function dclean() {
  volumes=`docker volume ls -q -f dangling=true`
  images=`docker images -f "dangling=true" -q`
  if [[ $volumes ]]; then
    docker volume rm $volumes
  fi
  if [[ $images ]]; then
    docker rmi $images
  fi
}

function dattach() {
  docker attach --detach-keys="ctrl-a" $(docker ps --format "{{.Names}} {{.ID}}" | grep "$1" | cut -d' ' -f2)
}

# unsets the nomatch error so we can run rake tasks like normal
unsetopt nomatch

# usage:
# whatisusing 3000
function whatisusing() {
  lsof -i tcp:$1 
}

# usage:
# dcop api
function dcop() {
  docker-compose exec $1 bundle exec rubocop 
}

# usage:
# dcopa api
function dcopa() {
  docker-compose exec $1 bundle exec rubocop -a
}

# usage:
# dspec api
function dspec() {
  docker-compose exec $1 bundle exec rspec
}

test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!!
export SDKMAN_DIR="/Users/katedonaldson/.sdkman"
[[ -s "/Users/katedonaldson/.sdkman/bin/sdkman-init.sh" ]] && source "/Users/katedonaldson/.sdkman/bin/sdkman-init.sh"

PATH="$HOME/Library/Python/3.7/bin:$PATH"
PATH="$HOME/Library/Python/3.9/bin:$PATH"
PATH="/usr/local/sbin:$PATH"
PATH="/opt/homebrew/bin:$PATH" # Add brew to path for M1 Chip
PATH="/opt/homebrew/opt/libpq/bin:$PATH"
PATH="$PATH:$HOME/.rvm/bin"

export PATH=$(printf "%s" "$PATH" | awk -v RS=':' '!a[$1]++ { if (NR > 1) printf RS; printf $1 }')

[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*

# for libpq to install the pg gem in ruby/rails apps
export PKG_CONFIG_PATH="/opt/homebrew/opt/libpq/lib/pkgconfig"

if command -v pyenv 1>/dev/null 2>&1; then
  eval "$(pyenv init -)"
else
  echo "pyenv not installed"
fi

export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm

# place this after nvm initialization!
autoload -U add-zsh-hook
load-nvmrc() {
  local node_version="$(nvm version)"
  local nvmrc_path="$(nvm_find_nvmrc)"

  if [ -n "$nvmrc_path" ]; then
    local nvmrc_node_version=$(nvm version "$(cat "${nvmrc_path}")")

    if [ "$nvmrc_node_version" = "N/A" ]; then
      nvm install
    elif [ "$nvmrc_node_version" != "$node_version" ]; then
      nvm use
    fi
  elif [ "$node_version" != "$(nvm version default)" ]; then
    echo "Reverting to nvm default version"
    nvm use default
  fi
}
add-zsh-hook chpwd load-nvmrc
load-nvmrc

source $HOME/.zprofile